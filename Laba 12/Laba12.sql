-- Задание 1 --


CREATE TABLE ROLES (
    ROLE_NAME NVARCHAR2(64) PRIMARY KEY
);

INSERT ALL
    INTO ROLES VALUES ('USER') -- PATIENT
    INTO ROLES VALUES ('ADMIN') -- ADMIN
    INTO ROLES VALUES ('AUTHOR') -- AUTHOR
SELECT 1 FROM DUAL;

CREATE TABLE USERS
(
    USER_ID    INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    USER_ROLE  NVARCHAR2(64) NOT NULL,
    USER_NAME  VARCHAR2(50)  NOT NULL,
    USER_LOGIN VARCHAR2(50)  NOT NULL UNIQUE,
    USER_PASS  VARCHAR2(100) NOT NULL,
    CONSTRAINT FK_USER_ROLE
        FOREIGN KEY (USER_ROLE)
            REFERENCES ROLES (ROLE_NAME)
);

CREATE TABLE SONG_USER (
    SONG_ID INT NOT NULL,
    USER_ID INT NOT NULL,

    FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID) ON DELETE CASCADE,
    FOREIGN KEY (SONG_ID) REFERENCES SONGS(SONG_ID) ON DELETE CASCADE
);




CREATE TABLE GENRES (
    GENRE_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    GENRE_NAME VARCHAR2(50) NOT NULL
);

INSERT INTO USERS (USER_ROLE, USER_NAME, USER_LOGIN, USER_PASS) VALUES    ('USER', 'Anton', 'user1_login', 'user1_pass');
INSERT INTO USERS (USER_ROLE, USER_NAME, USER_LOGIN, USER_PASS) VALUES    ('USER', 'Oleg', 'user2_login', 'user2_pass');
INSERT INTO USERS (USER_ROLE, USER_NAME, USER_LOGIN, USER_PASS) VALUES    ('ADMIN', 'Admin1', 'admin1_login', 'admin1_pass');
INSERT INTO USERS (USER_ROLE, USER_NAME, USER_LOGIN, USER_PASS) VALUES    ('AUTHOR', 'Author1', 'author1_login', 'author1_pass');

select * from  USERS;


INSERT INTO GENRES (GENRE_NAME) VALUES ('Rock');
INSERT INTO GENRES (GENRE_NAME) VALUES ('Pop');
INSERT INTO GENRES (GENRE_NAME) VALUES ('Jazz');

INSERT INTO SONGS (GENRE_ID, SONG, SONG_COVER, SONG_NAME, LISTENING_COUNTER, AUTHOR_ID) VALUES
(1, 'Song1', 'Cover1.jpg', 'Song One', 0, 4);
INSERT INTO SONGS (GENRE_ID, SONG, SONG_COVER, SONG_NAME, LISTENING_COUNTER, AUTHOR_ID)
VALUES (2, 'Song2', 'Cover2.jpg', 'Song Two', 0, 4);
INSERT INTO SONGS (GENRE_ID, SONG, SONG_COVER, SONG_NAME, LISTENING_COUNTER, AUTHOR_ID)
VALUES(3, 'Song3', 'Cover3.jpg', 'Song Three', 0, 4);

select  * from SONGS;
select  * from USERS;
select  * from SONG_USER;

insert into SONG_USER VALUES (3, 1);
insert into SONG_USER VALUES (4, 1);
insert into SONG_USER VALUES (5, 1);
insert into SONG_USER VALUES (5, 2);
insert into SONG_USER VALUES (4, 2);
insert into SONG_USER VALUES (3, 2);

delete SONGS where SONG_ID = 5;

-- Задание 3-4 --

delete SONGS where SONG_ID = 8;

select * from AUDIT_TRIGGER;
DROP TABLE SONGS;
DROP TABLE SONG_USER;

CREATE OR REPLACE TRIGGER before_operator_trigger
BEFORE INSERT OR DELETE OR UPDATE ON SONGS
DECLARE
BEGIN
    IF INSERTING THEN
        DBMS_OUTPUT.PUT_LINE('Триггер before_operator_trigger: Действие перед выполнением оператора INSERT.');
            INSERT INTO AUDIT_TRIGGER
            VALUES (CURRENT_DATE, 'INSERT', 'before_operator_trigger', 'ТРИГГЕР УРОВНЯ ОПЕРАТОРА');
    ELSIF UPDATING THEN
        DBMS_OUTPUT.PUT_LINE('Триггер before_operator_trigger: Действие перед выполнением оператора UPDATE.');
            INSERT INTO AUDIT_TRIGGER
            VALUES (CURRENT_DATE, 'UPDATE', 'before_operator_trigger', 'ТРИГГЕР УРОВНЯ ОПЕРАТОРА');
    ELSIF DELETING THEN
        DBMS_OUTPUT.PUT_LINE('Триггер before_operator_trigger: Действие перед выполнением оператора DELETE.');
            INSERT INTO AUDIT_TRIGGER
            VALUES (CURRENT_DATE, 'DELETE', 'before_operator_trigger', 'ТРИГГЕР УРОВНЯ ОПЕРАТОРА');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Триггер before_operator_trigger: Действие перед выполнением неизвестного оператора.');
    END IF;
END;

INSERT INTO SONGS (GENRE_ID, SONG, SONG_COVER, SONG_NAME, LISTENING_COUNTER, AUTHOR_ID)
VALUES(3, 'Song3', 'Cover3.jpg', 'Song Three', 0, 4);

-- Задание 5 --
CREATE OR REPLACE TRIGGER before_DELETE
BEFORE DELETE OR UPDATE  OR INSERT ON SONGS
FOR EACH ROW
DECLARE
BEGIN

    IF INSERTING THEN
        DBMS_OUTPUT.PUT_LINE('Триггер before_DELETE: Действие перед выполнением оператора INSERT над строкой.');
            INSERT INTO AUDIT_TRIGGER
            VALUES (CURRENT_DATE, 'INSERT', 'before_DELETE', :NEW.SONG_ID || ' ' || :NEW.SONG_NAME);
    ELSIF UPDATING THEN
        DBMS_OUTPUT.PUT_LINE('Триггер before_DELETE: Действие перед выполнением оператора UPDATE над строкой.');
            INSERT INTO AUDIT_TRIGGER
            VALUES (CURRENT_DATE, 'UPDATE', 'before_DELETE', 'Была  ' || :OLD.SONG_ID || ' ' || :OLD.SONG_NAME || ' => ' || :NEW.SONG_ID || ' ' || :NEW.SONG_NAME);
    ELSIF DELETING THEN
        DBMS_OUTPUT.PUT_LINE('Триггер before_DELETE: Действие перед выполнением оператора DELETE над строкой.');
            INSERT INTO AUDIT_TRIGGER
            VALUES (CURRENT_DATE, 'DELETE', 'before_DELETE', :OLD.SONG_ID || ' ' || :OLD.SONG_NAME);
    ELSE
        DBMS_OUTPUT.PUT_LINE('Триггер before_operator_trigger: Действие перед выполнением неизвестного оператора.');
    END IF;

END;

INSERT INTO SONGS (GENRE_ID, SONG, SONG_COVER, SONG_NAME, LISTENING_COUNTER, AUTHOR_ID)
VALUES(3, 'Song3', 'Cover3.jpg', 'Song Three', 0, 4);

-- Задание 7 --
CREATE OR REPLACE TRIGGER AFTER_INSERT_TRIGGER
AFTER INSERT ON SONGS
DECLARE
BEGIN
    INSERT INTO AUDIT_TRIGGER
    VALUES (CURRENT_DATE, 'INSERT', 'AFTER_INSERT_TRIGGER', 'ТРИГГЕР УРОВНЯ ОПЕРАТОРА');
    DBMS_OUTPUT.PUT_LINE('Триггер AFTER_INSERT_TRIGGER: После вставки.');
END;


INSERT INTO SONGS (GENRE_ID, SONG, SONG_COVER, SONG_NAME, LISTENING_COUNTER, AUTHOR_ID)
VALUES(3, 'Song3', 'Cover3.jpg', 'Моя песня', 0, 4);
--------------------------------------------------------------------------------------------------

CREATE OR REPLACE TRIGGER AFTER_UPDATE_TRIGGER
AFTER UPDATE ON SONGS
DECLARE
    BEGIN
        INSERT INTO AUDIT_TRIGGER
        VALUES (CURRENT_DATE, 'UPDATE', 'AFTER_UPDATE_TRIGGER', 'ТРИГГЕР УРОВНЯ ОПЕРАТОРА');
        DBMS_OUTPUT.PUT_LINE('Триггер AFTER_UPDATE_TRIGGER: После обновления.');
end;

UPDATE SONGS SET SONG_NAME = UPPER(SONG_NAME) WHERE SONG_NAME IS NOT NULL;

SELECT * FROM SONGS;
-----------------------------
CREATE OR REPLACE TRIGGER AFTER_DELETE_TRIGGER
AFTER DELETE ON SONGS
DECLARE
BEGIN
    INSERT INTO AUDIT_TRIGGER
    VALUES (CURRENT_DATE, 'DELETE', 'AFTER_DELETE_TRIGGER', 'ТРИГГЕР УРОВНЯ ОПЕРАТОРА');
    DBMS_OUTPUT.PUT_LINE('Триггер AFTER_DELETE_TRIGGER: После удаления.');
END;

DELETE SONGS
WHERE SONGS.SONG_ID = 10;
-- Задание 8 --

CREATE OR REPLACE TRIGGER AFTER_INSERT_TRIGGER_ROW
AFTER INSERT ON SONGS
FOR EACH ROW
DECLARE
BEGIN
    INSERT INTO AUDIT_TRIGGER
    VALUES (CURRENT_DATE, 'INSERT', 'AFTER_INSERT_TRIGGER_ROW', 'Была вставленна данная строка ' || :NEW.SONG_ID || ' ' || :NEW.SONG_NAME);
    DBMS_OUTPUT.PUT_LINE('Была вставленна данная строка ' || :NEW.SONG_ID || ' ' || :NEW.SONG_NAME);
    DBMS_OUTPUT.PUT_LINE('Триггер AFTER_INSERT_TRIGGER_ROW: После вставки.');
END;


INSERT INTO SONGS (GENRE_ID, SONG, SONG_COVER, SONG_NAME, LISTENING_COUNTER, AUTHOR_ID)
VALUES(3, 'Song3', 'Cover3.jpg', 'Моя песня', 0, 4);
--------------------------------------------------------------------------------------------------

CREATE OR REPLACE TRIGGER AFTER_UPADATE_TRIGGER_ROW
AFTER UPDATE ON SONGS
FOR EACH ROW
DECLARE
    BEGIN
        INSERT INTO AUDIT_TRIGGER
        VALUES (CURRENT_DATE, 'UPDATE', 'AFTER_UPADATE_TRIGGER_ROW', 'Была  ' || :OLD.SONG_ID || ' ' || :OLD.SONG_NAME || ' => ' || :NEW.SONG_ID || ' ' || :NEW.SONG_NAME);
        DBMS_OUTPUT.PUT_LINE('Была  ' || :OLD.SONG_ID || ' ' || :OLD.SONG_NAME || ' => ' || :NEW.SONG_ID || ' ' || :NEW.SONG_NAME);
        DBMS_OUTPUT.PUT_LINE('Триггер AFTER_UPADATE_TRIGGER_ROW: После обновления.');
end;

UPDATE SONGS SET SONG_NAME = LOWER(SONG_NAME) WHERE SONG_NAME IS NOT NULL;

SELECT * FROM SONGS;
-----------------------------
CREATE OR REPLACE TRIGGER AFTER_DELETE_TRIGGER_ROW
AFTER DELETE ON SONGS
FOR EACH ROW
DECLARE
BEGIN
    INSERT INTO AUDIT_TRIGGER
    VALUES (CURRENT_DATE, 'DELETE', 'AFTER_DELETE_TRIGGER_ROW', 'Была удалена строка ' || :OLD.SONG_ID || ' ' || :OLD.SONG_NAME);
    DBMS_OUTPUT.PUT_LINE('Была удалена строка ' || :OLD.SONG_ID || ' ' || :OLD.SONG_NAME);
    DBMS_OUTPUT.PUT_LINE('Триггер AFTER_DELETE_TRIGGER_ROW: После удаления.');
END;

DELETE SONGS
WHERE SONGS.SONG_ID = 11;

-- Задание 9 --

SELECT * FROM AUDIT_TRIGGER;

CREATE TABLE AUDIT_TRIGGER (
    OperationDate DATE NOT NULL,
    OperationType VARCHAR2(20),
    TriggerName VARCHAR2(50),
    Data VARCHAR2(200)
);

-- Задание 11 --
create table TEST_PK (
    A NVARCHAR2(64) PRIMARY KEY
);

CREATE OR REPLACE TRIGGER TEST_BEFOR_TRIGGER
BEFORE INSERT ON TEST_PK
FOR EACH ROW
DECLARE
BEGIN
    DBMS_OUTPUT.PUT_LINE('Была вставлена строка ' || :NEW.A );
    DBMS_OUTPUT.PUT_LINE('Триггер TEST_BEFOR_TRIGGER: Перед вставкой.');
END;

CREATE OR REPLACE TRIGGER TEST_AFTER_TRIGGER
AFTER INSERT ON TEST_PK
FOR EACH ROW
DECLARE
BEGIN
    DBMS_OUTPUT.PUT_LINE('Была вставлена строка ' || :NEW.A );
    DBMS_OUTPUT.PUT_LINE('Триггер TEST_AFTER_TRIGGER: После вставки.');
END;

INSERT INTO TEST_PK VALUES (1);

-- 12 - 13 --
CREATE OR REPLACE TRIGGER prevent_table_drop
BEFORE DROP ON SCHEMA
DECLARE
    v_object_name VARCHAR2(50);
    v_object_type VARCHAR2(50);
BEGIN
    -- Получаем имя и тип объекта, который пытаются удалить
    v_object_name := ORA_DICT_OBJ_NAME;
    SELECT object_type INTO v_object_type
    FROM user_objects
    WHERE object_name = v_object_name;

    -- Если тип объекта - таблица и имя объекта совпадает с вашей целевой таблицей, прерываем операцию
    IF v_object_type = 'TABLE' AND v_object_name = 'SONGS' THEN
        RAISE_APPLICATION_ERROR(-20001, 'Удаление таблицы ' || v_object_name || ' запрещено.');
    END IF;
END;
DROP TABLE SONG_USER;
DROP TABLE GENRES;
DROP TABLE GENRES;
DROP TABLE SONG_USER;
DROP TABLE SONGS;

DROP TRIGGER prevent_table_drop;

-- 14 --
-- Создание представления
CREATE OR REPLACE VIEW SONGS_VIEW AS
SELECT * FROM SONGS;

-- Создание INSTEAD OF INSERT триггера
CREATE OR REPLACE TRIGGER instead_of_insert_trigger
INSTEAD OF INSERT ON SONGS_VIEW
FOR EACH ROW
BEGIN
    -- Ваша логика обработки вставки
    INSERT INTO SONGS (GENRE_ID, SONG, SONG_COVER, SONG_NAME, LISTENING_COUNTER, AUTHOR_ID)
    VALUES (:NEW.GENRE_ID, :NEW.SONG, :NEW.SONG_COVER, 'Моя вввв', :NEW.LISTENING_COUNTER, :NEW.AUTHOR_ID);
END;

INSERT INTO SONGS_VIEW (GENRE_ID, SONG, SONG_COVER, LISTENING_COUNTER, AUTHOR_ID)
VALUES (1, 'Test Song', 'Test Cover', 0, 1);

select * from   SONGS;











